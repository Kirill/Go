.center.icon[![otus main](img/main.png)]

---


class: white
background-image: url(img/message.svg)
.top.icon[![otus main](img/logo.png)]

# Go-рутины и каналы

### Дмитрий Смаль

---

class: top white
background-image: url(img/sound.svg)
background-size: 130%
.top.icon[![otus main](img/logo.png)]

.sound-top[
  # Как меня слышно и видно?
]

.sound-bottom[
  ## > Напишите в чат
  ### **+** если все хорошо
  ### **-** если есть проблемы cо звуком или с видео
  ### !проверить запись!
]

---

# Небольшой тест

.left-text[
Пожалуйста, пройдите небольшой тест. 
<br><br>
Возможно вы уже многое знаете про Go-рутины и каналы в Go =)
<br><br>
[]()
]

.right-image[
![](img/gopher9.png)
]

---

# План занятия

.big-list[
* Горутины
* Каналы
* Буферизация каналов
* Примеры использования каналов
* О работе планировщика в Go
]

---

# Goroutine / Горутины

Горутины - обычные функции, которые выполняются конкурентно (в пересекающиеся моменты времени).
Горутины - легковесные, у каждой из них свой стек, все остальное (память, файлы и т.п.) - общее.
Запуск новой горутины производится с помощью ключевого слова `go`.

```
func main() {
  go func(arg string) {
    time.Sleep(10*time.Second)
    fmt.Println("hello", arg)
  }("world")  // передача аргументов в горутину
  
  fmt.Println("main")
  time.Sleep(10*time.Second)
  fmt.Println("main again")
}
```
Или
```
go list.Sort()
```

Горутина завершается когда происходит выход из функции или когда завершается основная программа (функция main).

---


# Каналы

Канал - тип (и механизм) в Go, предназначенный для синхронизации горутин и передачи данных между ними.
Канал работает по принципу FIFO.

```
var c chan string       // Канал для передачи строк

var c chan int          // Канал не инициализирован, nil

var c = make(chan int)  //  Канал инициализирован, емкость - 0

var c = make(chan int, 10)  // Емкость буфера 10 элементов
```

Каналы могу быть:
* на чтение / на запись / и то и другое
* буферизованными / небуферизованными
* открытыми / закрытыми

---

# Чтение и запись в канал

Запись в канал осуществляется оператором `<-` справа от канала, т.е. `ch <- value`
```
var ch = make(chan int, 10)

ch <- 42
```

Чтение из канала - также оператором `<-`, но слева от канала

```
var i int

i := <- ch      // получить данные из канала в переменную i

i, ok := <- ch  // получить данные и флаг открытости

<- ch           // получить и отбросить данные из канала
```

В один канал могут писать (и читать из него) несколько горутин.

---

# Пример работы канала

```
func primeChecker(in chan int, out chan int) {
  for {
    i := <- in
    if isPrime(i) {
      out <- i
    }
  }
}

func main() {
  var inCh = make(chan int, 10)
  var outCh = make(chan int, 10)

  go primeChecker(inCh, outCh)
  // go primeChecker(inCh, outCh)
  go func() {
    for {
      fmt.Println(<- outCh)
    }
  }()

  for i := 0; i < 1000000; i++ {
    inCh <- i
  }
}
```

---

# Итерация по каналу

Значения из канала удобно получать в цикле с помощью `range`. <br>

Функции с предыдущего слайда можно переписать как:

```
func primeChecker(in chan int, out chan int) {
  for i := range in {
    if isPrime(i) {
      out <- i
    }
  }
}

go func() {
  for j := range outCh {
    fmt.Println(j)
  }
}()
```

---

# Закрытие канала

Канал можно "закрыть" с помощью встроенной функции `close`.

После "закрытия" канала:
* чтение из него будет возвращать zero value для типа канала
* запись в него приведет к panic (!)
* итерация с помощью `range` прекратиться
* оператор `select` будет сразу всегда возвращать zero value

```
var in = make(chan int, 10)
go func() {
  for i := range in {
  }
}()
go func() {
  for {
    i, ok := <- in
    if !ok {
      return
    }
  }
}()
close(in)
```

Best practise: *Закрывать канал должна пишущая горутина, либо создатель!*

---

# Отправка сигналов

Закрытие канала - один из способов "послать сигнал" горутине.

```
var start = make(chan struct{}) // "барьер"

for i := 0; i < 10000; i++ {

  go func() {
    <- start
    // горутины не начнут работу
    // пока не будут созданы все 10000
  }()

}

close(start)
```

---

# Каналы на чтение и на запись

В Go есть возможность уточнить способ использования (чтение/запись) канала, указав это при объявлении типа.
Тип канал-на-чтение объявляется как `<-chan T`, канал-на-запись как `chan<- T`

```
func primeChecker(in <-chan int, out chan<- int) {
  // из in можно только читать
  // в out можно только писать
}

var inCh = make(chan int, 10)
var outCh = make(chan int, 10)

primeChecker(inCh, outCh) // автоматическое преобразование типов
```

Формально `chan T`, `<-chan T` и `chan<- T` - различные типы данных, однако при присвоении (с уточнением) работает автоматическое преобразование типа.

---

# Пустые и полные каналы

Что произойдет ?

```
var ch1 = make(chan int, 10)
i := <- ch1
```

А в таком случае ?

```
var ch2 = make(chan int, 10)
for i := 0; i < 20; i++ {
  ch2 <- i
}
```

---

# Буферизация каналов

Запись в канал возможна, если есть горутина, вызвавшая операцию чтения из канала, либо есть место в буфере.
И наоборот чтение возможно, если есть горутина, вызвавшая операцию записи, либо есть данные в буфере.
<br><br>

```
var notBuffered = make(chan int)  // буфера нет

var buffered = make(chan int, 10) // длинна буфера 10

buffered <- 1
buffered <- 2
buffered <- 3  // сработает, даже если никто не читает

// функции len и cap показывают размер и заполненость буфера
fmt.Println(len(buffered)) // 3
fmt.Println(cap(buffered)) // 10

```

Основное назначение *буферизованных* каналов - эффективный и *неблокирующий* обмен данными между горутинами

---

# Небуферизованные каналы

---

# Конструкция select

Конструкция `select` в Go позволяет одновременно читать/писать в несколько каналов.

```

```

---

# select default

# Паттерны использования каналов
- завершение горутины
- передача задач (параллелизация)
- получение ответов
- каналы каналов
- семафоры (?)
- Не выводить каналы в публичный интерфейс
- leaky bucket
    
# Таймеры и работа со временем

# Внутренняя структура канала

# Работа планировщика Go
TODO
- когда происходит переключение 
- что происходит при обращении к сети и каналу
- что происходит при записи на диск и системном вызове

---

# Небольшой тест

.left-text[
Проверим что мы узнали за этот урок
<br><br>
[]()
]

.right-image[
![](img/gopher9.png)
]

---

# Домашнее задание

---

# Опрос

.left-text[
Заполните пожалуйста опрос
<br><br>
[]()
]

.right-image[
![](img/gopher7.png)
]

---

class: white
background-image: url(img/message.svg)
.top.icon[![otus main](img/logo.png)]

# Спасибо за внимание!


---
